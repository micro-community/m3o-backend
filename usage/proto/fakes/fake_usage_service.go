// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"context"
	"sync"

	usage "github.com/m3o/services/usage/proto"
	"github.com/micro/micro/v3/service/client"
)

type FakeUsageService struct {
	DeleteCustomerStub        func(context.Context, *usage.DeleteCustomerRequest, ...client.CallOption) (*usage.DeleteCustomerResponse, error)
	deleteCustomerMutex       sync.RWMutex
	deleteCustomerArgsForCall []struct {
		arg1 context.Context
		arg2 *usage.DeleteCustomerRequest
		arg3 []client.CallOption
	}
	deleteCustomerReturns struct {
		result1 *usage.DeleteCustomerResponse
		result2 error
	}
	deleteCustomerReturnsOnCall map[int]struct {
		result1 *usage.DeleteCustomerResponse
		result2 error
	}
	ListAPIRanksStub        func(context.Context, *usage.ListAPIRanksRequest, ...client.CallOption) (*usage.ListAPIRanksResponse, error)
	listAPIRanksMutex       sync.RWMutex
	listAPIRanksArgsForCall []struct {
		arg1 context.Context
		arg2 *usage.ListAPIRanksRequest
		arg3 []client.CallOption
	}
	listAPIRanksReturns struct {
		result1 *usage.ListAPIRanksResponse
		result2 error
	}
	listAPIRanksReturnsOnCall map[int]struct {
		result1 *usage.ListAPIRanksResponse
		result2 error
	}
	ListEventsStub        func(context.Context, *usage.ListEventsRequest, ...client.CallOption) (*usage.ListEventsResponse, error)
	listEventsMutex       sync.RWMutex
	listEventsArgsForCall []struct {
		arg1 context.Context
		arg2 *usage.ListEventsRequest
		arg3 []client.CallOption
	}
	listEventsReturns struct {
		result1 *usage.ListEventsResponse
		result2 error
	}
	listEventsReturnsOnCall map[int]struct {
		result1 *usage.ListEventsResponse
		result2 error
	}
	ReadStub        func(context.Context, *usage.ReadRequest, ...client.CallOption) (*usage.ReadResponse, error)
	readMutex       sync.RWMutex
	readArgsForCall []struct {
		arg1 context.Context
		arg2 *usage.ReadRequest
		arg3 []client.CallOption
	}
	readReturns struct {
		result1 *usage.ReadResponse
		result2 error
	}
	readReturnsOnCall map[int]struct {
		result1 *usage.ReadResponse
		result2 error
	}
	ReadMonthlyTotalStub        func(context.Context, *usage.ReadMonthlyTotalRequest, ...client.CallOption) (*usage.ReadMonthlyTotalResponse, error)
	readMonthlyTotalMutex       sync.RWMutex
	readMonthlyTotalArgsForCall []struct {
		arg1 context.Context
		arg2 *usage.ReadMonthlyTotalRequest
		arg3 []client.CallOption
	}
	readMonthlyTotalReturns struct {
		result1 *usage.ReadMonthlyTotalResponse
		result2 error
	}
	readMonthlyTotalReturnsOnCall map[int]struct {
		result1 *usage.ReadMonthlyTotalResponse
		result2 error
	}
	SaveEventStub        func(context.Context, *usage.SaveEventRequest, ...client.CallOption) (*usage.SaveEventResponse, error)
	saveEventMutex       sync.RWMutex
	saveEventArgsForCall []struct {
		arg1 context.Context
		arg2 *usage.SaveEventRequest
		arg3 []client.CallOption
	}
	saveEventReturns struct {
		result1 *usage.SaveEventResponse
		result2 error
	}
	saveEventReturnsOnCall map[int]struct {
		result1 *usage.SaveEventResponse
		result2 error
	}
	SweepStub        func(context.Context, *usage.SweepRequest, ...client.CallOption) (*usage.SweepResponse, error)
	sweepMutex       sync.RWMutex
	sweepArgsForCall []struct {
		arg1 context.Context
		arg2 *usage.SweepRequest
		arg3 []client.CallOption
	}
	sweepReturns struct {
		result1 *usage.SweepResponse
		result2 error
	}
	sweepReturnsOnCall map[int]struct {
		result1 *usage.SweepResponse
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeUsageService) DeleteCustomer(arg1 context.Context, arg2 *usage.DeleteCustomerRequest, arg3 ...client.CallOption) (*usage.DeleteCustomerResponse, error) {
	fake.deleteCustomerMutex.Lock()
	ret, specificReturn := fake.deleteCustomerReturnsOnCall[len(fake.deleteCustomerArgsForCall)]
	fake.deleteCustomerArgsForCall = append(fake.deleteCustomerArgsForCall, struct {
		arg1 context.Context
		arg2 *usage.DeleteCustomerRequest
		arg3 []client.CallOption
	}{arg1, arg2, arg3})
	stub := fake.DeleteCustomerStub
	fakeReturns := fake.deleteCustomerReturns
	fake.recordInvocation("DeleteCustomer", []interface{}{arg1, arg2, arg3})
	fake.deleteCustomerMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUsageService) DeleteCustomerCallCount() int {
	fake.deleteCustomerMutex.RLock()
	defer fake.deleteCustomerMutex.RUnlock()
	return len(fake.deleteCustomerArgsForCall)
}

func (fake *FakeUsageService) DeleteCustomerCalls(stub func(context.Context, *usage.DeleteCustomerRequest, ...client.CallOption) (*usage.DeleteCustomerResponse, error)) {
	fake.deleteCustomerMutex.Lock()
	defer fake.deleteCustomerMutex.Unlock()
	fake.DeleteCustomerStub = stub
}

func (fake *FakeUsageService) DeleteCustomerArgsForCall(i int) (context.Context, *usage.DeleteCustomerRequest, []client.CallOption) {
	fake.deleteCustomerMutex.RLock()
	defer fake.deleteCustomerMutex.RUnlock()
	argsForCall := fake.deleteCustomerArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeUsageService) DeleteCustomerReturns(result1 *usage.DeleteCustomerResponse, result2 error) {
	fake.deleteCustomerMutex.Lock()
	defer fake.deleteCustomerMutex.Unlock()
	fake.DeleteCustomerStub = nil
	fake.deleteCustomerReturns = struct {
		result1 *usage.DeleteCustomerResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeUsageService) DeleteCustomerReturnsOnCall(i int, result1 *usage.DeleteCustomerResponse, result2 error) {
	fake.deleteCustomerMutex.Lock()
	defer fake.deleteCustomerMutex.Unlock()
	fake.DeleteCustomerStub = nil
	if fake.deleteCustomerReturnsOnCall == nil {
		fake.deleteCustomerReturnsOnCall = make(map[int]struct {
			result1 *usage.DeleteCustomerResponse
			result2 error
		})
	}
	fake.deleteCustomerReturnsOnCall[i] = struct {
		result1 *usage.DeleteCustomerResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeUsageService) ListAPIRanks(arg1 context.Context, arg2 *usage.ListAPIRanksRequest, arg3 ...client.CallOption) (*usage.ListAPIRanksResponse, error) {
	fake.listAPIRanksMutex.Lock()
	ret, specificReturn := fake.listAPIRanksReturnsOnCall[len(fake.listAPIRanksArgsForCall)]
	fake.listAPIRanksArgsForCall = append(fake.listAPIRanksArgsForCall, struct {
		arg1 context.Context
		arg2 *usage.ListAPIRanksRequest
		arg3 []client.CallOption
	}{arg1, arg2, arg3})
	stub := fake.ListAPIRanksStub
	fakeReturns := fake.listAPIRanksReturns
	fake.recordInvocation("ListAPIRanks", []interface{}{arg1, arg2, arg3})
	fake.listAPIRanksMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUsageService) ListAPIRanksCallCount() int {
	fake.listAPIRanksMutex.RLock()
	defer fake.listAPIRanksMutex.RUnlock()
	return len(fake.listAPIRanksArgsForCall)
}

func (fake *FakeUsageService) ListAPIRanksCalls(stub func(context.Context, *usage.ListAPIRanksRequest, ...client.CallOption) (*usage.ListAPIRanksResponse, error)) {
	fake.listAPIRanksMutex.Lock()
	defer fake.listAPIRanksMutex.Unlock()
	fake.ListAPIRanksStub = stub
}

func (fake *FakeUsageService) ListAPIRanksArgsForCall(i int) (context.Context, *usage.ListAPIRanksRequest, []client.CallOption) {
	fake.listAPIRanksMutex.RLock()
	defer fake.listAPIRanksMutex.RUnlock()
	argsForCall := fake.listAPIRanksArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeUsageService) ListAPIRanksReturns(result1 *usage.ListAPIRanksResponse, result2 error) {
	fake.listAPIRanksMutex.Lock()
	defer fake.listAPIRanksMutex.Unlock()
	fake.ListAPIRanksStub = nil
	fake.listAPIRanksReturns = struct {
		result1 *usage.ListAPIRanksResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeUsageService) ListAPIRanksReturnsOnCall(i int, result1 *usage.ListAPIRanksResponse, result2 error) {
	fake.listAPIRanksMutex.Lock()
	defer fake.listAPIRanksMutex.Unlock()
	fake.ListAPIRanksStub = nil
	if fake.listAPIRanksReturnsOnCall == nil {
		fake.listAPIRanksReturnsOnCall = make(map[int]struct {
			result1 *usage.ListAPIRanksResponse
			result2 error
		})
	}
	fake.listAPIRanksReturnsOnCall[i] = struct {
		result1 *usage.ListAPIRanksResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeUsageService) ListEvents(arg1 context.Context, arg2 *usage.ListEventsRequest, arg3 ...client.CallOption) (*usage.ListEventsResponse, error) {
	fake.listEventsMutex.Lock()
	ret, specificReturn := fake.listEventsReturnsOnCall[len(fake.listEventsArgsForCall)]
	fake.listEventsArgsForCall = append(fake.listEventsArgsForCall, struct {
		arg1 context.Context
		arg2 *usage.ListEventsRequest
		arg3 []client.CallOption
	}{arg1, arg2, arg3})
	stub := fake.ListEventsStub
	fakeReturns := fake.listEventsReturns
	fake.recordInvocation("ListEvents", []interface{}{arg1, arg2, arg3})
	fake.listEventsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUsageService) ListEventsCallCount() int {
	fake.listEventsMutex.RLock()
	defer fake.listEventsMutex.RUnlock()
	return len(fake.listEventsArgsForCall)
}

func (fake *FakeUsageService) ListEventsCalls(stub func(context.Context, *usage.ListEventsRequest, ...client.CallOption) (*usage.ListEventsResponse, error)) {
	fake.listEventsMutex.Lock()
	defer fake.listEventsMutex.Unlock()
	fake.ListEventsStub = stub
}

func (fake *FakeUsageService) ListEventsArgsForCall(i int) (context.Context, *usage.ListEventsRequest, []client.CallOption) {
	fake.listEventsMutex.RLock()
	defer fake.listEventsMutex.RUnlock()
	argsForCall := fake.listEventsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeUsageService) ListEventsReturns(result1 *usage.ListEventsResponse, result2 error) {
	fake.listEventsMutex.Lock()
	defer fake.listEventsMutex.Unlock()
	fake.ListEventsStub = nil
	fake.listEventsReturns = struct {
		result1 *usage.ListEventsResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeUsageService) ListEventsReturnsOnCall(i int, result1 *usage.ListEventsResponse, result2 error) {
	fake.listEventsMutex.Lock()
	defer fake.listEventsMutex.Unlock()
	fake.ListEventsStub = nil
	if fake.listEventsReturnsOnCall == nil {
		fake.listEventsReturnsOnCall = make(map[int]struct {
			result1 *usage.ListEventsResponse
			result2 error
		})
	}
	fake.listEventsReturnsOnCall[i] = struct {
		result1 *usage.ListEventsResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeUsageService) Read(arg1 context.Context, arg2 *usage.ReadRequest, arg3 ...client.CallOption) (*usage.ReadResponse, error) {
	fake.readMutex.Lock()
	ret, specificReturn := fake.readReturnsOnCall[len(fake.readArgsForCall)]
	fake.readArgsForCall = append(fake.readArgsForCall, struct {
		arg1 context.Context
		arg2 *usage.ReadRequest
		arg3 []client.CallOption
	}{arg1, arg2, arg3})
	stub := fake.ReadStub
	fakeReturns := fake.readReturns
	fake.recordInvocation("Read", []interface{}{arg1, arg2, arg3})
	fake.readMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUsageService) ReadCallCount() int {
	fake.readMutex.RLock()
	defer fake.readMutex.RUnlock()
	return len(fake.readArgsForCall)
}

func (fake *FakeUsageService) ReadCalls(stub func(context.Context, *usage.ReadRequest, ...client.CallOption) (*usage.ReadResponse, error)) {
	fake.readMutex.Lock()
	defer fake.readMutex.Unlock()
	fake.ReadStub = stub
}

func (fake *FakeUsageService) ReadArgsForCall(i int) (context.Context, *usage.ReadRequest, []client.CallOption) {
	fake.readMutex.RLock()
	defer fake.readMutex.RUnlock()
	argsForCall := fake.readArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeUsageService) ReadReturns(result1 *usage.ReadResponse, result2 error) {
	fake.readMutex.Lock()
	defer fake.readMutex.Unlock()
	fake.ReadStub = nil
	fake.readReturns = struct {
		result1 *usage.ReadResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeUsageService) ReadReturnsOnCall(i int, result1 *usage.ReadResponse, result2 error) {
	fake.readMutex.Lock()
	defer fake.readMutex.Unlock()
	fake.ReadStub = nil
	if fake.readReturnsOnCall == nil {
		fake.readReturnsOnCall = make(map[int]struct {
			result1 *usage.ReadResponse
			result2 error
		})
	}
	fake.readReturnsOnCall[i] = struct {
		result1 *usage.ReadResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeUsageService) ReadMonthlyTotal(arg1 context.Context, arg2 *usage.ReadMonthlyTotalRequest, arg3 ...client.CallOption) (*usage.ReadMonthlyTotalResponse, error) {
	fake.readMonthlyTotalMutex.Lock()
	ret, specificReturn := fake.readMonthlyTotalReturnsOnCall[len(fake.readMonthlyTotalArgsForCall)]
	fake.readMonthlyTotalArgsForCall = append(fake.readMonthlyTotalArgsForCall, struct {
		arg1 context.Context
		arg2 *usage.ReadMonthlyTotalRequest
		arg3 []client.CallOption
	}{arg1, arg2, arg3})
	stub := fake.ReadMonthlyTotalStub
	fakeReturns := fake.readMonthlyTotalReturns
	fake.recordInvocation("ReadMonthlyTotal", []interface{}{arg1, arg2, arg3})
	fake.readMonthlyTotalMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUsageService) ReadMonthlyTotalCallCount() int {
	fake.readMonthlyTotalMutex.RLock()
	defer fake.readMonthlyTotalMutex.RUnlock()
	return len(fake.readMonthlyTotalArgsForCall)
}

func (fake *FakeUsageService) ReadMonthlyTotalCalls(stub func(context.Context, *usage.ReadMonthlyTotalRequest, ...client.CallOption) (*usage.ReadMonthlyTotalResponse, error)) {
	fake.readMonthlyTotalMutex.Lock()
	defer fake.readMonthlyTotalMutex.Unlock()
	fake.ReadMonthlyTotalStub = stub
}

func (fake *FakeUsageService) ReadMonthlyTotalArgsForCall(i int) (context.Context, *usage.ReadMonthlyTotalRequest, []client.CallOption) {
	fake.readMonthlyTotalMutex.RLock()
	defer fake.readMonthlyTotalMutex.RUnlock()
	argsForCall := fake.readMonthlyTotalArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeUsageService) ReadMonthlyTotalReturns(result1 *usage.ReadMonthlyTotalResponse, result2 error) {
	fake.readMonthlyTotalMutex.Lock()
	defer fake.readMonthlyTotalMutex.Unlock()
	fake.ReadMonthlyTotalStub = nil
	fake.readMonthlyTotalReturns = struct {
		result1 *usage.ReadMonthlyTotalResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeUsageService) ReadMonthlyTotalReturnsOnCall(i int, result1 *usage.ReadMonthlyTotalResponse, result2 error) {
	fake.readMonthlyTotalMutex.Lock()
	defer fake.readMonthlyTotalMutex.Unlock()
	fake.ReadMonthlyTotalStub = nil
	if fake.readMonthlyTotalReturnsOnCall == nil {
		fake.readMonthlyTotalReturnsOnCall = make(map[int]struct {
			result1 *usage.ReadMonthlyTotalResponse
			result2 error
		})
	}
	fake.readMonthlyTotalReturnsOnCall[i] = struct {
		result1 *usage.ReadMonthlyTotalResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeUsageService) SaveEvent(arg1 context.Context, arg2 *usage.SaveEventRequest, arg3 ...client.CallOption) (*usage.SaveEventResponse, error) {
	fake.saveEventMutex.Lock()
	ret, specificReturn := fake.saveEventReturnsOnCall[len(fake.saveEventArgsForCall)]
	fake.saveEventArgsForCall = append(fake.saveEventArgsForCall, struct {
		arg1 context.Context
		arg2 *usage.SaveEventRequest
		arg3 []client.CallOption
	}{arg1, arg2, arg3})
	stub := fake.SaveEventStub
	fakeReturns := fake.saveEventReturns
	fake.recordInvocation("SaveEvent", []interface{}{arg1, arg2, arg3})
	fake.saveEventMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUsageService) SaveEventCallCount() int {
	fake.saveEventMutex.RLock()
	defer fake.saveEventMutex.RUnlock()
	return len(fake.saveEventArgsForCall)
}

func (fake *FakeUsageService) SaveEventCalls(stub func(context.Context, *usage.SaveEventRequest, ...client.CallOption) (*usage.SaveEventResponse, error)) {
	fake.saveEventMutex.Lock()
	defer fake.saveEventMutex.Unlock()
	fake.SaveEventStub = stub
}

func (fake *FakeUsageService) SaveEventArgsForCall(i int) (context.Context, *usage.SaveEventRequest, []client.CallOption) {
	fake.saveEventMutex.RLock()
	defer fake.saveEventMutex.RUnlock()
	argsForCall := fake.saveEventArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeUsageService) SaveEventReturns(result1 *usage.SaveEventResponse, result2 error) {
	fake.saveEventMutex.Lock()
	defer fake.saveEventMutex.Unlock()
	fake.SaveEventStub = nil
	fake.saveEventReturns = struct {
		result1 *usage.SaveEventResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeUsageService) SaveEventReturnsOnCall(i int, result1 *usage.SaveEventResponse, result2 error) {
	fake.saveEventMutex.Lock()
	defer fake.saveEventMutex.Unlock()
	fake.SaveEventStub = nil
	if fake.saveEventReturnsOnCall == nil {
		fake.saveEventReturnsOnCall = make(map[int]struct {
			result1 *usage.SaveEventResponse
			result2 error
		})
	}
	fake.saveEventReturnsOnCall[i] = struct {
		result1 *usage.SaveEventResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeUsageService) Sweep(arg1 context.Context, arg2 *usage.SweepRequest, arg3 ...client.CallOption) (*usage.SweepResponse, error) {
	fake.sweepMutex.Lock()
	ret, specificReturn := fake.sweepReturnsOnCall[len(fake.sweepArgsForCall)]
	fake.sweepArgsForCall = append(fake.sweepArgsForCall, struct {
		arg1 context.Context
		arg2 *usage.SweepRequest
		arg3 []client.CallOption
	}{arg1, arg2, arg3})
	stub := fake.SweepStub
	fakeReturns := fake.sweepReturns
	fake.recordInvocation("Sweep", []interface{}{arg1, arg2, arg3})
	fake.sweepMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUsageService) SweepCallCount() int {
	fake.sweepMutex.RLock()
	defer fake.sweepMutex.RUnlock()
	return len(fake.sweepArgsForCall)
}

func (fake *FakeUsageService) SweepCalls(stub func(context.Context, *usage.SweepRequest, ...client.CallOption) (*usage.SweepResponse, error)) {
	fake.sweepMutex.Lock()
	defer fake.sweepMutex.Unlock()
	fake.SweepStub = stub
}

func (fake *FakeUsageService) SweepArgsForCall(i int) (context.Context, *usage.SweepRequest, []client.CallOption) {
	fake.sweepMutex.RLock()
	defer fake.sweepMutex.RUnlock()
	argsForCall := fake.sweepArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeUsageService) SweepReturns(result1 *usage.SweepResponse, result2 error) {
	fake.sweepMutex.Lock()
	defer fake.sweepMutex.Unlock()
	fake.SweepStub = nil
	fake.sweepReturns = struct {
		result1 *usage.SweepResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeUsageService) SweepReturnsOnCall(i int, result1 *usage.SweepResponse, result2 error) {
	fake.sweepMutex.Lock()
	defer fake.sweepMutex.Unlock()
	fake.SweepStub = nil
	if fake.sweepReturnsOnCall == nil {
		fake.sweepReturnsOnCall = make(map[int]struct {
			result1 *usage.SweepResponse
			result2 error
		})
	}
	fake.sweepReturnsOnCall[i] = struct {
		result1 *usage.SweepResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeUsageService) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.deleteCustomerMutex.RLock()
	defer fake.deleteCustomerMutex.RUnlock()
	fake.listAPIRanksMutex.RLock()
	defer fake.listAPIRanksMutex.RUnlock()
	fake.listEventsMutex.RLock()
	defer fake.listEventsMutex.RUnlock()
	fake.readMutex.RLock()
	defer fake.readMutex.RUnlock()
	fake.readMonthlyTotalMutex.RLock()
	defer fake.readMonthlyTotalMutex.RUnlock()
	fake.saveEventMutex.RLock()
	defer fake.saveEventMutex.RUnlock()
	fake.sweepMutex.RLock()
	defer fake.sweepMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeUsageService) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ usage.UsageService = new(FakeUsageService)
