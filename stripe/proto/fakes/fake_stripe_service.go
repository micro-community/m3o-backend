// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"context"
	"sync"

	stripe "github.com/m3o/services/stripe/proto"
	"github.com/micro/micro/v3/service/client"
)

type FakeStripeService struct {
	ChargeCardStub        func(context.Context, *stripe.ChargeCardRequest, ...client.CallOption) (*stripe.ChargeCardResponse, error)
	chargeCardMutex       sync.RWMutex
	chargeCardArgsForCall []struct {
		arg1 context.Context
		arg2 *stripe.ChargeCardRequest
		arg3 []client.CallOption
	}
	chargeCardReturns struct {
		result1 *stripe.ChargeCardResponse
		result2 error
	}
	chargeCardReturnsOnCall map[int]struct {
		result1 *stripe.ChargeCardResponse
		result2 error
	}
	CreateCheckoutSessionStub        func(context.Context, *stripe.CreateCheckoutSessionRequest, ...client.CallOption) (*stripe.CreateCheckoutSessionResponse, error)
	createCheckoutSessionMutex       sync.RWMutex
	createCheckoutSessionArgsForCall []struct {
		arg1 context.Context
		arg2 *stripe.CreateCheckoutSessionRequest
		arg3 []client.CallOption
	}
	createCheckoutSessionReturns struct {
		result1 *stripe.CreateCheckoutSessionResponse
		result2 error
	}
	createCheckoutSessionReturnsOnCall map[int]struct {
		result1 *stripe.CreateCheckoutSessionResponse
		result2 error
	}
	DeleteCardStub        func(context.Context, *stripe.DeleteCardRequest, ...client.CallOption) (*stripe.DeleteCardResponse, error)
	deleteCardMutex       sync.RWMutex
	deleteCardArgsForCall []struct {
		arg1 context.Context
		arg2 *stripe.DeleteCardRequest
		arg3 []client.CallOption
	}
	deleteCardReturns struct {
		result1 *stripe.DeleteCardResponse
		result2 error
	}
	deleteCardReturnsOnCall map[int]struct {
		result1 *stripe.DeleteCardResponse
		result2 error
	}
	GetPaymentStub        func(context.Context, *stripe.GetPaymentRequest, ...client.CallOption) (*stripe.GetPaymentResponse, error)
	getPaymentMutex       sync.RWMutex
	getPaymentArgsForCall []struct {
		arg1 context.Context
		arg2 *stripe.GetPaymentRequest
		arg3 []client.CallOption
	}
	getPaymentReturns struct {
		result1 *stripe.GetPaymentResponse
		result2 error
	}
	getPaymentReturnsOnCall map[int]struct {
		result1 *stripe.GetPaymentResponse
		result2 error
	}
	ListCardsStub        func(context.Context, *stripe.ListCardsRequest, ...client.CallOption) (*stripe.ListCardsResponse, error)
	listCardsMutex       sync.RWMutex
	listCardsArgsForCall []struct {
		arg1 context.Context
		arg2 *stripe.ListCardsRequest
		arg3 []client.CallOption
	}
	listCardsReturns struct {
		result1 *stripe.ListCardsResponse
		result2 error
	}
	listCardsReturnsOnCall map[int]struct {
		result1 *stripe.ListCardsResponse
		result2 error
	}
	ListPaymentsStub        func(context.Context, *stripe.ListPaymentsRequest, ...client.CallOption) (*stripe.ListPaymentsResponse, error)
	listPaymentsMutex       sync.RWMutex
	listPaymentsArgsForCall []struct {
		arg1 context.Context
		arg2 *stripe.ListPaymentsRequest
		arg3 []client.CallOption
	}
	listPaymentsReturns struct {
		result1 *stripe.ListPaymentsResponse
		result2 error
	}
	listPaymentsReturnsOnCall map[int]struct {
		result1 *stripe.ListPaymentsResponse
		result2 error
	}
	SetupCardStub        func(context.Context, *stripe.SetupCardRequest, ...client.CallOption) (*stripe.SetupCardResponse, error)
	setupCardMutex       sync.RWMutex
	setupCardArgsForCall []struct {
		arg1 context.Context
		arg2 *stripe.SetupCardRequest
		arg3 []client.CallOption
	}
	setupCardReturns struct {
		result1 *stripe.SetupCardResponse
		result2 error
	}
	setupCardReturnsOnCall map[int]struct {
		result1 *stripe.SetupCardResponse
		result2 error
	}
	SubscribeStub        func(context.Context, *stripe.SubscribeRequest, ...client.CallOption) (*stripe.SubscribeResponse, error)
	subscribeMutex       sync.RWMutex
	subscribeArgsForCall []struct {
		arg1 context.Context
		arg2 *stripe.SubscribeRequest
		arg3 []client.CallOption
	}
	subscribeReturns struct {
		result1 *stripe.SubscribeResponse
		result2 error
	}
	subscribeReturnsOnCall map[int]struct {
		result1 *stripe.SubscribeResponse
		result2 error
	}
	UnsubscribeStub        func(context.Context, *stripe.UnsubscribeRequest, ...client.CallOption) (*stripe.UnsubscribeResponse, error)
	unsubscribeMutex       sync.RWMutex
	unsubscribeArgsForCall []struct {
		arg1 context.Context
		arg2 *stripe.UnsubscribeRequest
		arg3 []client.CallOption
	}
	unsubscribeReturns struct {
		result1 *stripe.UnsubscribeResponse
		result2 error
	}
	unsubscribeReturnsOnCall map[int]struct {
		result1 *stripe.UnsubscribeResponse
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeStripeService) ChargeCard(arg1 context.Context, arg2 *stripe.ChargeCardRequest, arg3 ...client.CallOption) (*stripe.ChargeCardResponse, error) {
	fake.chargeCardMutex.Lock()
	ret, specificReturn := fake.chargeCardReturnsOnCall[len(fake.chargeCardArgsForCall)]
	fake.chargeCardArgsForCall = append(fake.chargeCardArgsForCall, struct {
		arg1 context.Context
		arg2 *stripe.ChargeCardRequest
		arg3 []client.CallOption
	}{arg1, arg2, arg3})
	stub := fake.ChargeCardStub
	fakeReturns := fake.chargeCardReturns
	fake.recordInvocation("ChargeCard", []interface{}{arg1, arg2, arg3})
	fake.chargeCardMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStripeService) ChargeCardCallCount() int {
	fake.chargeCardMutex.RLock()
	defer fake.chargeCardMutex.RUnlock()
	return len(fake.chargeCardArgsForCall)
}

func (fake *FakeStripeService) ChargeCardCalls(stub func(context.Context, *stripe.ChargeCardRequest, ...client.CallOption) (*stripe.ChargeCardResponse, error)) {
	fake.chargeCardMutex.Lock()
	defer fake.chargeCardMutex.Unlock()
	fake.ChargeCardStub = stub
}

func (fake *FakeStripeService) ChargeCardArgsForCall(i int) (context.Context, *stripe.ChargeCardRequest, []client.CallOption) {
	fake.chargeCardMutex.RLock()
	defer fake.chargeCardMutex.RUnlock()
	argsForCall := fake.chargeCardArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeStripeService) ChargeCardReturns(result1 *stripe.ChargeCardResponse, result2 error) {
	fake.chargeCardMutex.Lock()
	defer fake.chargeCardMutex.Unlock()
	fake.ChargeCardStub = nil
	fake.chargeCardReturns = struct {
		result1 *stripe.ChargeCardResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeStripeService) ChargeCardReturnsOnCall(i int, result1 *stripe.ChargeCardResponse, result2 error) {
	fake.chargeCardMutex.Lock()
	defer fake.chargeCardMutex.Unlock()
	fake.ChargeCardStub = nil
	if fake.chargeCardReturnsOnCall == nil {
		fake.chargeCardReturnsOnCall = make(map[int]struct {
			result1 *stripe.ChargeCardResponse
			result2 error
		})
	}
	fake.chargeCardReturnsOnCall[i] = struct {
		result1 *stripe.ChargeCardResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeStripeService) CreateCheckoutSession(arg1 context.Context, arg2 *stripe.CreateCheckoutSessionRequest, arg3 ...client.CallOption) (*stripe.CreateCheckoutSessionResponse, error) {
	fake.createCheckoutSessionMutex.Lock()
	ret, specificReturn := fake.createCheckoutSessionReturnsOnCall[len(fake.createCheckoutSessionArgsForCall)]
	fake.createCheckoutSessionArgsForCall = append(fake.createCheckoutSessionArgsForCall, struct {
		arg1 context.Context
		arg2 *stripe.CreateCheckoutSessionRequest
		arg3 []client.CallOption
	}{arg1, arg2, arg3})
	stub := fake.CreateCheckoutSessionStub
	fakeReturns := fake.createCheckoutSessionReturns
	fake.recordInvocation("CreateCheckoutSession", []interface{}{arg1, arg2, arg3})
	fake.createCheckoutSessionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStripeService) CreateCheckoutSessionCallCount() int {
	fake.createCheckoutSessionMutex.RLock()
	defer fake.createCheckoutSessionMutex.RUnlock()
	return len(fake.createCheckoutSessionArgsForCall)
}

func (fake *FakeStripeService) CreateCheckoutSessionCalls(stub func(context.Context, *stripe.CreateCheckoutSessionRequest, ...client.CallOption) (*stripe.CreateCheckoutSessionResponse, error)) {
	fake.createCheckoutSessionMutex.Lock()
	defer fake.createCheckoutSessionMutex.Unlock()
	fake.CreateCheckoutSessionStub = stub
}

func (fake *FakeStripeService) CreateCheckoutSessionArgsForCall(i int) (context.Context, *stripe.CreateCheckoutSessionRequest, []client.CallOption) {
	fake.createCheckoutSessionMutex.RLock()
	defer fake.createCheckoutSessionMutex.RUnlock()
	argsForCall := fake.createCheckoutSessionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeStripeService) CreateCheckoutSessionReturns(result1 *stripe.CreateCheckoutSessionResponse, result2 error) {
	fake.createCheckoutSessionMutex.Lock()
	defer fake.createCheckoutSessionMutex.Unlock()
	fake.CreateCheckoutSessionStub = nil
	fake.createCheckoutSessionReturns = struct {
		result1 *stripe.CreateCheckoutSessionResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeStripeService) CreateCheckoutSessionReturnsOnCall(i int, result1 *stripe.CreateCheckoutSessionResponse, result2 error) {
	fake.createCheckoutSessionMutex.Lock()
	defer fake.createCheckoutSessionMutex.Unlock()
	fake.CreateCheckoutSessionStub = nil
	if fake.createCheckoutSessionReturnsOnCall == nil {
		fake.createCheckoutSessionReturnsOnCall = make(map[int]struct {
			result1 *stripe.CreateCheckoutSessionResponse
			result2 error
		})
	}
	fake.createCheckoutSessionReturnsOnCall[i] = struct {
		result1 *stripe.CreateCheckoutSessionResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeStripeService) DeleteCard(arg1 context.Context, arg2 *stripe.DeleteCardRequest, arg3 ...client.CallOption) (*stripe.DeleteCardResponse, error) {
	fake.deleteCardMutex.Lock()
	ret, specificReturn := fake.deleteCardReturnsOnCall[len(fake.deleteCardArgsForCall)]
	fake.deleteCardArgsForCall = append(fake.deleteCardArgsForCall, struct {
		arg1 context.Context
		arg2 *stripe.DeleteCardRequest
		arg3 []client.CallOption
	}{arg1, arg2, arg3})
	stub := fake.DeleteCardStub
	fakeReturns := fake.deleteCardReturns
	fake.recordInvocation("DeleteCard", []interface{}{arg1, arg2, arg3})
	fake.deleteCardMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStripeService) DeleteCardCallCount() int {
	fake.deleteCardMutex.RLock()
	defer fake.deleteCardMutex.RUnlock()
	return len(fake.deleteCardArgsForCall)
}

func (fake *FakeStripeService) DeleteCardCalls(stub func(context.Context, *stripe.DeleteCardRequest, ...client.CallOption) (*stripe.DeleteCardResponse, error)) {
	fake.deleteCardMutex.Lock()
	defer fake.deleteCardMutex.Unlock()
	fake.DeleteCardStub = stub
}

func (fake *FakeStripeService) DeleteCardArgsForCall(i int) (context.Context, *stripe.DeleteCardRequest, []client.CallOption) {
	fake.deleteCardMutex.RLock()
	defer fake.deleteCardMutex.RUnlock()
	argsForCall := fake.deleteCardArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeStripeService) DeleteCardReturns(result1 *stripe.DeleteCardResponse, result2 error) {
	fake.deleteCardMutex.Lock()
	defer fake.deleteCardMutex.Unlock()
	fake.DeleteCardStub = nil
	fake.deleteCardReturns = struct {
		result1 *stripe.DeleteCardResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeStripeService) DeleteCardReturnsOnCall(i int, result1 *stripe.DeleteCardResponse, result2 error) {
	fake.deleteCardMutex.Lock()
	defer fake.deleteCardMutex.Unlock()
	fake.DeleteCardStub = nil
	if fake.deleteCardReturnsOnCall == nil {
		fake.deleteCardReturnsOnCall = make(map[int]struct {
			result1 *stripe.DeleteCardResponse
			result2 error
		})
	}
	fake.deleteCardReturnsOnCall[i] = struct {
		result1 *stripe.DeleteCardResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeStripeService) GetPayment(arg1 context.Context, arg2 *stripe.GetPaymentRequest, arg3 ...client.CallOption) (*stripe.GetPaymentResponse, error) {
	fake.getPaymentMutex.Lock()
	ret, specificReturn := fake.getPaymentReturnsOnCall[len(fake.getPaymentArgsForCall)]
	fake.getPaymentArgsForCall = append(fake.getPaymentArgsForCall, struct {
		arg1 context.Context
		arg2 *stripe.GetPaymentRequest
		arg3 []client.CallOption
	}{arg1, arg2, arg3})
	stub := fake.GetPaymentStub
	fakeReturns := fake.getPaymentReturns
	fake.recordInvocation("GetPayment", []interface{}{arg1, arg2, arg3})
	fake.getPaymentMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStripeService) GetPaymentCallCount() int {
	fake.getPaymentMutex.RLock()
	defer fake.getPaymentMutex.RUnlock()
	return len(fake.getPaymentArgsForCall)
}

func (fake *FakeStripeService) GetPaymentCalls(stub func(context.Context, *stripe.GetPaymentRequest, ...client.CallOption) (*stripe.GetPaymentResponse, error)) {
	fake.getPaymentMutex.Lock()
	defer fake.getPaymentMutex.Unlock()
	fake.GetPaymentStub = stub
}

func (fake *FakeStripeService) GetPaymentArgsForCall(i int) (context.Context, *stripe.GetPaymentRequest, []client.CallOption) {
	fake.getPaymentMutex.RLock()
	defer fake.getPaymentMutex.RUnlock()
	argsForCall := fake.getPaymentArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeStripeService) GetPaymentReturns(result1 *stripe.GetPaymentResponse, result2 error) {
	fake.getPaymentMutex.Lock()
	defer fake.getPaymentMutex.Unlock()
	fake.GetPaymentStub = nil
	fake.getPaymentReturns = struct {
		result1 *stripe.GetPaymentResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeStripeService) GetPaymentReturnsOnCall(i int, result1 *stripe.GetPaymentResponse, result2 error) {
	fake.getPaymentMutex.Lock()
	defer fake.getPaymentMutex.Unlock()
	fake.GetPaymentStub = nil
	if fake.getPaymentReturnsOnCall == nil {
		fake.getPaymentReturnsOnCall = make(map[int]struct {
			result1 *stripe.GetPaymentResponse
			result2 error
		})
	}
	fake.getPaymentReturnsOnCall[i] = struct {
		result1 *stripe.GetPaymentResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeStripeService) ListCards(arg1 context.Context, arg2 *stripe.ListCardsRequest, arg3 ...client.CallOption) (*stripe.ListCardsResponse, error) {
	fake.listCardsMutex.Lock()
	ret, specificReturn := fake.listCardsReturnsOnCall[len(fake.listCardsArgsForCall)]
	fake.listCardsArgsForCall = append(fake.listCardsArgsForCall, struct {
		arg1 context.Context
		arg2 *stripe.ListCardsRequest
		arg3 []client.CallOption
	}{arg1, arg2, arg3})
	stub := fake.ListCardsStub
	fakeReturns := fake.listCardsReturns
	fake.recordInvocation("ListCards", []interface{}{arg1, arg2, arg3})
	fake.listCardsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStripeService) ListCardsCallCount() int {
	fake.listCardsMutex.RLock()
	defer fake.listCardsMutex.RUnlock()
	return len(fake.listCardsArgsForCall)
}

func (fake *FakeStripeService) ListCardsCalls(stub func(context.Context, *stripe.ListCardsRequest, ...client.CallOption) (*stripe.ListCardsResponse, error)) {
	fake.listCardsMutex.Lock()
	defer fake.listCardsMutex.Unlock()
	fake.ListCardsStub = stub
}

func (fake *FakeStripeService) ListCardsArgsForCall(i int) (context.Context, *stripe.ListCardsRequest, []client.CallOption) {
	fake.listCardsMutex.RLock()
	defer fake.listCardsMutex.RUnlock()
	argsForCall := fake.listCardsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeStripeService) ListCardsReturns(result1 *stripe.ListCardsResponse, result2 error) {
	fake.listCardsMutex.Lock()
	defer fake.listCardsMutex.Unlock()
	fake.ListCardsStub = nil
	fake.listCardsReturns = struct {
		result1 *stripe.ListCardsResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeStripeService) ListCardsReturnsOnCall(i int, result1 *stripe.ListCardsResponse, result2 error) {
	fake.listCardsMutex.Lock()
	defer fake.listCardsMutex.Unlock()
	fake.ListCardsStub = nil
	if fake.listCardsReturnsOnCall == nil {
		fake.listCardsReturnsOnCall = make(map[int]struct {
			result1 *stripe.ListCardsResponse
			result2 error
		})
	}
	fake.listCardsReturnsOnCall[i] = struct {
		result1 *stripe.ListCardsResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeStripeService) ListPayments(arg1 context.Context, arg2 *stripe.ListPaymentsRequest, arg3 ...client.CallOption) (*stripe.ListPaymentsResponse, error) {
	fake.listPaymentsMutex.Lock()
	ret, specificReturn := fake.listPaymentsReturnsOnCall[len(fake.listPaymentsArgsForCall)]
	fake.listPaymentsArgsForCall = append(fake.listPaymentsArgsForCall, struct {
		arg1 context.Context
		arg2 *stripe.ListPaymentsRequest
		arg3 []client.CallOption
	}{arg1, arg2, arg3})
	stub := fake.ListPaymentsStub
	fakeReturns := fake.listPaymentsReturns
	fake.recordInvocation("ListPayments", []interface{}{arg1, arg2, arg3})
	fake.listPaymentsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStripeService) ListPaymentsCallCount() int {
	fake.listPaymentsMutex.RLock()
	defer fake.listPaymentsMutex.RUnlock()
	return len(fake.listPaymentsArgsForCall)
}

func (fake *FakeStripeService) ListPaymentsCalls(stub func(context.Context, *stripe.ListPaymentsRequest, ...client.CallOption) (*stripe.ListPaymentsResponse, error)) {
	fake.listPaymentsMutex.Lock()
	defer fake.listPaymentsMutex.Unlock()
	fake.ListPaymentsStub = stub
}

func (fake *FakeStripeService) ListPaymentsArgsForCall(i int) (context.Context, *stripe.ListPaymentsRequest, []client.CallOption) {
	fake.listPaymentsMutex.RLock()
	defer fake.listPaymentsMutex.RUnlock()
	argsForCall := fake.listPaymentsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeStripeService) ListPaymentsReturns(result1 *stripe.ListPaymentsResponse, result2 error) {
	fake.listPaymentsMutex.Lock()
	defer fake.listPaymentsMutex.Unlock()
	fake.ListPaymentsStub = nil
	fake.listPaymentsReturns = struct {
		result1 *stripe.ListPaymentsResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeStripeService) ListPaymentsReturnsOnCall(i int, result1 *stripe.ListPaymentsResponse, result2 error) {
	fake.listPaymentsMutex.Lock()
	defer fake.listPaymentsMutex.Unlock()
	fake.ListPaymentsStub = nil
	if fake.listPaymentsReturnsOnCall == nil {
		fake.listPaymentsReturnsOnCall = make(map[int]struct {
			result1 *stripe.ListPaymentsResponse
			result2 error
		})
	}
	fake.listPaymentsReturnsOnCall[i] = struct {
		result1 *stripe.ListPaymentsResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeStripeService) SetupCard(arg1 context.Context, arg2 *stripe.SetupCardRequest, arg3 ...client.CallOption) (*stripe.SetupCardResponse, error) {
	fake.setupCardMutex.Lock()
	ret, specificReturn := fake.setupCardReturnsOnCall[len(fake.setupCardArgsForCall)]
	fake.setupCardArgsForCall = append(fake.setupCardArgsForCall, struct {
		arg1 context.Context
		arg2 *stripe.SetupCardRequest
		arg3 []client.CallOption
	}{arg1, arg2, arg3})
	stub := fake.SetupCardStub
	fakeReturns := fake.setupCardReturns
	fake.recordInvocation("SetupCard", []interface{}{arg1, arg2, arg3})
	fake.setupCardMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStripeService) SetupCardCallCount() int {
	fake.setupCardMutex.RLock()
	defer fake.setupCardMutex.RUnlock()
	return len(fake.setupCardArgsForCall)
}

func (fake *FakeStripeService) SetupCardCalls(stub func(context.Context, *stripe.SetupCardRequest, ...client.CallOption) (*stripe.SetupCardResponse, error)) {
	fake.setupCardMutex.Lock()
	defer fake.setupCardMutex.Unlock()
	fake.SetupCardStub = stub
}

func (fake *FakeStripeService) SetupCardArgsForCall(i int) (context.Context, *stripe.SetupCardRequest, []client.CallOption) {
	fake.setupCardMutex.RLock()
	defer fake.setupCardMutex.RUnlock()
	argsForCall := fake.setupCardArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeStripeService) SetupCardReturns(result1 *stripe.SetupCardResponse, result2 error) {
	fake.setupCardMutex.Lock()
	defer fake.setupCardMutex.Unlock()
	fake.SetupCardStub = nil
	fake.setupCardReturns = struct {
		result1 *stripe.SetupCardResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeStripeService) SetupCardReturnsOnCall(i int, result1 *stripe.SetupCardResponse, result2 error) {
	fake.setupCardMutex.Lock()
	defer fake.setupCardMutex.Unlock()
	fake.SetupCardStub = nil
	if fake.setupCardReturnsOnCall == nil {
		fake.setupCardReturnsOnCall = make(map[int]struct {
			result1 *stripe.SetupCardResponse
			result2 error
		})
	}
	fake.setupCardReturnsOnCall[i] = struct {
		result1 *stripe.SetupCardResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeStripeService) Subscribe(arg1 context.Context, arg2 *stripe.SubscribeRequest, arg3 ...client.CallOption) (*stripe.SubscribeResponse, error) {
	fake.subscribeMutex.Lock()
	ret, specificReturn := fake.subscribeReturnsOnCall[len(fake.subscribeArgsForCall)]
	fake.subscribeArgsForCall = append(fake.subscribeArgsForCall, struct {
		arg1 context.Context
		arg2 *stripe.SubscribeRequest
		arg3 []client.CallOption
	}{arg1, arg2, arg3})
	stub := fake.SubscribeStub
	fakeReturns := fake.subscribeReturns
	fake.recordInvocation("Subscribe", []interface{}{arg1, arg2, arg3})
	fake.subscribeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStripeService) SubscribeCallCount() int {
	fake.subscribeMutex.RLock()
	defer fake.subscribeMutex.RUnlock()
	return len(fake.subscribeArgsForCall)
}

func (fake *FakeStripeService) SubscribeCalls(stub func(context.Context, *stripe.SubscribeRequest, ...client.CallOption) (*stripe.SubscribeResponse, error)) {
	fake.subscribeMutex.Lock()
	defer fake.subscribeMutex.Unlock()
	fake.SubscribeStub = stub
}

func (fake *FakeStripeService) SubscribeArgsForCall(i int) (context.Context, *stripe.SubscribeRequest, []client.CallOption) {
	fake.subscribeMutex.RLock()
	defer fake.subscribeMutex.RUnlock()
	argsForCall := fake.subscribeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeStripeService) SubscribeReturns(result1 *stripe.SubscribeResponse, result2 error) {
	fake.subscribeMutex.Lock()
	defer fake.subscribeMutex.Unlock()
	fake.SubscribeStub = nil
	fake.subscribeReturns = struct {
		result1 *stripe.SubscribeResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeStripeService) SubscribeReturnsOnCall(i int, result1 *stripe.SubscribeResponse, result2 error) {
	fake.subscribeMutex.Lock()
	defer fake.subscribeMutex.Unlock()
	fake.SubscribeStub = nil
	if fake.subscribeReturnsOnCall == nil {
		fake.subscribeReturnsOnCall = make(map[int]struct {
			result1 *stripe.SubscribeResponse
			result2 error
		})
	}
	fake.subscribeReturnsOnCall[i] = struct {
		result1 *stripe.SubscribeResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeStripeService) Unsubscribe(arg1 context.Context, arg2 *stripe.UnsubscribeRequest, arg3 ...client.CallOption) (*stripe.UnsubscribeResponse, error) {
	fake.unsubscribeMutex.Lock()
	ret, specificReturn := fake.unsubscribeReturnsOnCall[len(fake.unsubscribeArgsForCall)]
	fake.unsubscribeArgsForCall = append(fake.unsubscribeArgsForCall, struct {
		arg1 context.Context
		arg2 *stripe.UnsubscribeRequest
		arg3 []client.CallOption
	}{arg1, arg2, arg3})
	stub := fake.UnsubscribeStub
	fakeReturns := fake.unsubscribeReturns
	fake.recordInvocation("Unsubscribe", []interface{}{arg1, arg2, arg3})
	fake.unsubscribeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStripeService) UnsubscribeCallCount() int {
	fake.unsubscribeMutex.RLock()
	defer fake.unsubscribeMutex.RUnlock()
	return len(fake.unsubscribeArgsForCall)
}

func (fake *FakeStripeService) UnsubscribeCalls(stub func(context.Context, *stripe.UnsubscribeRequest, ...client.CallOption) (*stripe.UnsubscribeResponse, error)) {
	fake.unsubscribeMutex.Lock()
	defer fake.unsubscribeMutex.Unlock()
	fake.UnsubscribeStub = stub
}

func (fake *FakeStripeService) UnsubscribeArgsForCall(i int) (context.Context, *stripe.UnsubscribeRequest, []client.CallOption) {
	fake.unsubscribeMutex.RLock()
	defer fake.unsubscribeMutex.RUnlock()
	argsForCall := fake.unsubscribeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeStripeService) UnsubscribeReturns(result1 *stripe.UnsubscribeResponse, result2 error) {
	fake.unsubscribeMutex.Lock()
	defer fake.unsubscribeMutex.Unlock()
	fake.UnsubscribeStub = nil
	fake.unsubscribeReturns = struct {
		result1 *stripe.UnsubscribeResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeStripeService) UnsubscribeReturnsOnCall(i int, result1 *stripe.UnsubscribeResponse, result2 error) {
	fake.unsubscribeMutex.Lock()
	defer fake.unsubscribeMutex.Unlock()
	fake.UnsubscribeStub = nil
	if fake.unsubscribeReturnsOnCall == nil {
		fake.unsubscribeReturnsOnCall = make(map[int]struct {
			result1 *stripe.UnsubscribeResponse
			result2 error
		})
	}
	fake.unsubscribeReturnsOnCall[i] = struct {
		result1 *stripe.UnsubscribeResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeStripeService) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.chargeCardMutex.RLock()
	defer fake.chargeCardMutex.RUnlock()
	fake.createCheckoutSessionMutex.RLock()
	defer fake.createCheckoutSessionMutex.RUnlock()
	fake.deleteCardMutex.RLock()
	defer fake.deleteCardMutex.RUnlock()
	fake.getPaymentMutex.RLock()
	defer fake.getPaymentMutex.RUnlock()
	fake.listCardsMutex.RLock()
	defer fake.listCardsMutex.RUnlock()
	fake.listPaymentsMutex.RLock()
	defer fake.listPaymentsMutex.RUnlock()
	fake.setupCardMutex.RLock()
	defer fake.setupCardMutex.RUnlock()
	fake.subscribeMutex.RLock()
	defer fake.subscribeMutex.RUnlock()
	fake.unsubscribeMutex.RLock()
	defer fake.unsubscribeMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeStripeService) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ stripe.StripeService = new(FakeStripeService)
