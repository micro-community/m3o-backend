// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"context"
	"sync"

	billing "github.com/m3o/services/billing/proto"
	"github.com/micro/micro/v3/service/client"
)

type FakeBillingService struct {
	ChargeCardStub        func(context.Context, *billing.ChargeCardRequest, ...client.CallOption) (*billing.ChargeCardResponse, error)
	chargeCardMutex       sync.RWMutex
	chargeCardArgsForCall []struct {
		arg1 context.Context
		arg2 *billing.ChargeCardRequest
		arg3 []client.CallOption
	}
	chargeCardReturns struct {
		result1 *billing.ChargeCardResponse
		result2 error
	}
	chargeCardReturnsOnCall map[int]struct {
		result1 *billing.ChargeCardResponse
		result2 error
	}
	CreateCheckoutSessionStub        func(context.Context, *billing.CreateCheckoutSessionRequest, ...client.CallOption) (*billing.CreateCheckoutSessionResponse, error)
	createCheckoutSessionMutex       sync.RWMutex
	createCheckoutSessionArgsForCall []struct {
		arg1 context.Context
		arg2 *billing.CreateCheckoutSessionRequest
		arg3 []client.CallOption
	}
	createCheckoutSessionReturns struct {
		result1 *billing.CreateCheckoutSessionResponse
		result2 error
	}
	createCheckoutSessionReturnsOnCall map[int]struct {
		result1 *billing.CreateCheckoutSessionResponse
		result2 error
	}
	DeleteCardStub        func(context.Context, *billing.DeleteCardRequest, ...client.CallOption) (*billing.DeleteCardResponse, error)
	deleteCardMutex       sync.RWMutex
	deleteCardArgsForCall []struct {
		arg1 context.Context
		arg2 *billing.DeleteCardRequest
		arg3 []client.CallOption
	}
	deleteCardReturns struct {
		result1 *billing.DeleteCardResponse
		result2 error
	}
	deleteCardReturnsOnCall map[int]struct {
		result1 *billing.DeleteCardResponse
		result2 error
	}
	GetPaymentStub        func(context.Context, *billing.GetPaymentRequest, ...client.CallOption) (*billing.GetPaymentResponse, error)
	getPaymentMutex       sync.RWMutex
	getPaymentArgsForCall []struct {
		arg1 context.Context
		arg2 *billing.GetPaymentRequest
		arg3 []client.CallOption
	}
	getPaymentReturns struct {
		result1 *billing.GetPaymentResponse
		result2 error
	}
	getPaymentReturnsOnCall map[int]struct {
		result1 *billing.GetPaymentResponse
		result2 error
	}
	ListCardsStub        func(context.Context, *billing.ListCardsRequest, ...client.CallOption) (*billing.ListCardsResponse, error)
	listCardsMutex       sync.RWMutex
	listCardsArgsForCall []struct {
		arg1 context.Context
		arg2 *billing.ListCardsRequest
		arg3 []client.CallOption
	}
	listCardsReturns struct {
		result1 *billing.ListCardsResponse
		result2 error
	}
	listCardsReturnsOnCall map[int]struct {
		result1 *billing.ListCardsResponse
		result2 error
	}
	ListPaymentsStub        func(context.Context, *billing.ListPaymentsRequest, ...client.CallOption) (*billing.ListPaymentsResponse, error)
	listPaymentsMutex       sync.RWMutex
	listPaymentsArgsForCall []struct {
		arg1 context.Context
		arg2 *billing.ListPaymentsRequest
		arg3 []client.CallOption
	}
	listPaymentsReturns struct {
		result1 *billing.ListPaymentsResponse
		result2 error
	}
	listPaymentsReturnsOnCall map[int]struct {
		result1 *billing.ListPaymentsResponse
		result2 error
	}
	ReadAccountStub        func(context.Context, *billing.ReadAccountRequest, ...client.CallOption) (*billing.ReadAccountResponse, error)
	readAccountMutex       sync.RWMutex
	readAccountArgsForCall []struct {
		arg1 context.Context
		arg2 *billing.ReadAccountRequest
		arg3 []client.CallOption
	}
	readAccountReturns struct {
		result1 *billing.ReadAccountResponse
		result2 error
	}
	readAccountReturnsOnCall map[int]struct {
		result1 *billing.ReadAccountResponse
		result2 error
	}
	SetupCardStub        func(context.Context, *billing.SetupCardRequest, ...client.CallOption) (*billing.SetupCardResponse, error)
	setupCardMutex       sync.RWMutex
	setupCardArgsForCall []struct {
		arg1 context.Context
		arg2 *billing.SetupCardRequest
		arg3 []client.CallOption
	}
	setupCardReturns struct {
		result1 *billing.SetupCardResponse
		result2 error
	}
	setupCardReturnsOnCall map[int]struct {
		result1 *billing.SetupCardResponse
		result2 error
	}
	SubscribeTierStub        func(context.Context, *billing.SubscribeTierRequest, ...client.CallOption) (*billing.SubscribeTierResponse, error)
	subscribeTierMutex       sync.RWMutex
	subscribeTierArgsForCall []struct {
		arg1 context.Context
		arg2 *billing.SubscribeTierRequest
		arg3 []client.CallOption
	}
	subscribeTierReturns struct {
		result1 *billing.SubscribeTierResponse
		result2 error
	}
	subscribeTierReturnsOnCall map[int]struct {
		result1 *billing.SubscribeTierResponse
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeBillingService) ChargeCard(arg1 context.Context, arg2 *billing.ChargeCardRequest, arg3 ...client.CallOption) (*billing.ChargeCardResponse, error) {
	fake.chargeCardMutex.Lock()
	ret, specificReturn := fake.chargeCardReturnsOnCall[len(fake.chargeCardArgsForCall)]
	fake.chargeCardArgsForCall = append(fake.chargeCardArgsForCall, struct {
		arg1 context.Context
		arg2 *billing.ChargeCardRequest
		arg3 []client.CallOption
	}{arg1, arg2, arg3})
	stub := fake.ChargeCardStub
	fakeReturns := fake.chargeCardReturns
	fake.recordInvocation("ChargeCard", []interface{}{arg1, arg2, arg3})
	fake.chargeCardMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeBillingService) ChargeCardCallCount() int {
	fake.chargeCardMutex.RLock()
	defer fake.chargeCardMutex.RUnlock()
	return len(fake.chargeCardArgsForCall)
}

func (fake *FakeBillingService) ChargeCardCalls(stub func(context.Context, *billing.ChargeCardRequest, ...client.CallOption) (*billing.ChargeCardResponse, error)) {
	fake.chargeCardMutex.Lock()
	defer fake.chargeCardMutex.Unlock()
	fake.ChargeCardStub = stub
}

func (fake *FakeBillingService) ChargeCardArgsForCall(i int) (context.Context, *billing.ChargeCardRequest, []client.CallOption) {
	fake.chargeCardMutex.RLock()
	defer fake.chargeCardMutex.RUnlock()
	argsForCall := fake.chargeCardArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeBillingService) ChargeCardReturns(result1 *billing.ChargeCardResponse, result2 error) {
	fake.chargeCardMutex.Lock()
	defer fake.chargeCardMutex.Unlock()
	fake.ChargeCardStub = nil
	fake.chargeCardReturns = struct {
		result1 *billing.ChargeCardResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeBillingService) ChargeCardReturnsOnCall(i int, result1 *billing.ChargeCardResponse, result2 error) {
	fake.chargeCardMutex.Lock()
	defer fake.chargeCardMutex.Unlock()
	fake.ChargeCardStub = nil
	if fake.chargeCardReturnsOnCall == nil {
		fake.chargeCardReturnsOnCall = make(map[int]struct {
			result1 *billing.ChargeCardResponse
			result2 error
		})
	}
	fake.chargeCardReturnsOnCall[i] = struct {
		result1 *billing.ChargeCardResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeBillingService) CreateCheckoutSession(arg1 context.Context, arg2 *billing.CreateCheckoutSessionRequest, arg3 ...client.CallOption) (*billing.CreateCheckoutSessionResponse, error) {
	fake.createCheckoutSessionMutex.Lock()
	ret, specificReturn := fake.createCheckoutSessionReturnsOnCall[len(fake.createCheckoutSessionArgsForCall)]
	fake.createCheckoutSessionArgsForCall = append(fake.createCheckoutSessionArgsForCall, struct {
		arg1 context.Context
		arg2 *billing.CreateCheckoutSessionRequest
		arg3 []client.CallOption
	}{arg1, arg2, arg3})
	stub := fake.CreateCheckoutSessionStub
	fakeReturns := fake.createCheckoutSessionReturns
	fake.recordInvocation("CreateCheckoutSession", []interface{}{arg1, arg2, arg3})
	fake.createCheckoutSessionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeBillingService) CreateCheckoutSessionCallCount() int {
	fake.createCheckoutSessionMutex.RLock()
	defer fake.createCheckoutSessionMutex.RUnlock()
	return len(fake.createCheckoutSessionArgsForCall)
}

func (fake *FakeBillingService) CreateCheckoutSessionCalls(stub func(context.Context, *billing.CreateCheckoutSessionRequest, ...client.CallOption) (*billing.CreateCheckoutSessionResponse, error)) {
	fake.createCheckoutSessionMutex.Lock()
	defer fake.createCheckoutSessionMutex.Unlock()
	fake.CreateCheckoutSessionStub = stub
}

func (fake *FakeBillingService) CreateCheckoutSessionArgsForCall(i int) (context.Context, *billing.CreateCheckoutSessionRequest, []client.CallOption) {
	fake.createCheckoutSessionMutex.RLock()
	defer fake.createCheckoutSessionMutex.RUnlock()
	argsForCall := fake.createCheckoutSessionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeBillingService) CreateCheckoutSessionReturns(result1 *billing.CreateCheckoutSessionResponse, result2 error) {
	fake.createCheckoutSessionMutex.Lock()
	defer fake.createCheckoutSessionMutex.Unlock()
	fake.CreateCheckoutSessionStub = nil
	fake.createCheckoutSessionReturns = struct {
		result1 *billing.CreateCheckoutSessionResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeBillingService) CreateCheckoutSessionReturnsOnCall(i int, result1 *billing.CreateCheckoutSessionResponse, result2 error) {
	fake.createCheckoutSessionMutex.Lock()
	defer fake.createCheckoutSessionMutex.Unlock()
	fake.CreateCheckoutSessionStub = nil
	if fake.createCheckoutSessionReturnsOnCall == nil {
		fake.createCheckoutSessionReturnsOnCall = make(map[int]struct {
			result1 *billing.CreateCheckoutSessionResponse
			result2 error
		})
	}
	fake.createCheckoutSessionReturnsOnCall[i] = struct {
		result1 *billing.CreateCheckoutSessionResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeBillingService) DeleteCard(arg1 context.Context, arg2 *billing.DeleteCardRequest, arg3 ...client.CallOption) (*billing.DeleteCardResponse, error) {
	fake.deleteCardMutex.Lock()
	ret, specificReturn := fake.deleteCardReturnsOnCall[len(fake.deleteCardArgsForCall)]
	fake.deleteCardArgsForCall = append(fake.deleteCardArgsForCall, struct {
		arg1 context.Context
		arg2 *billing.DeleteCardRequest
		arg3 []client.CallOption
	}{arg1, arg2, arg3})
	stub := fake.DeleteCardStub
	fakeReturns := fake.deleteCardReturns
	fake.recordInvocation("DeleteCard", []interface{}{arg1, arg2, arg3})
	fake.deleteCardMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeBillingService) DeleteCardCallCount() int {
	fake.deleteCardMutex.RLock()
	defer fake.deleteCardMutex.RUnlock()
	return len(fake.deleteCardArgsForCall)
}

func (fake *FakeBillingService) DeleteCardCalls(stub func(context.Context, *billing.DeleteCardRequest, ...client.CallOption) (*billing.DeleteCardResponse, error)) {
	fake.deleteCardMutex.Lock()
	defer fake.deleteCardMutex.Unlock()
	fake.DeleteCardStub = stub
}

func (fake *FakeBillingService) DeleteCardArgsForCall(i int) (context.Context, *billing.DeleteCardRequest, []client.CallOption) {
	fake.deleteCardMutex.RLock()
	defer fake.deleteCardMutex.RUnlock()
	argsForCall := fake.deleteCardArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeBillingService) DeleteCardReturns(result1 *billing.DeleteCardResponse, result2 error) {
	fake.deleteCardMutex.Lock()
	defer fake.deleteCardMutex.Unlock()
	fake.DeleteCardStub = nil
	fake.deleteCardReturns = struct {
		result1 *billing.DeleteCardResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeBillingService) DeleteCardReturnsOnCall(i int, result1 *billing.DeleteCardResponse, result2 error) {
	fake.deleteCardMutex.Lock()
	defer fake.deleteCardMutex.Unlock()
	fake.DeleteCardStub = nil
	if fake.deleteCardReturnsOnCall == nil {
		fake.deleteCardReturnsOnCall = make(map[int]struct {
			result1 *billing.DeleteCardResponse
			result2 error
		})
	}
	fake.deleteCardReturnsOnCall[i] = struct {
		result1 *billing.DeleteCardResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeBillingService) GetPayment(arg1 context.Context, arg2 *billing.GetPaymentRequest, arg3 ...client.CallOption) (*billing.GetPaymentResponse, error) {
	fake.getPaymentMutex.Lock()
	ret, specificReturn := fake.getPaymentReturnsOnCall[len(fake.getPaymentArgsForCall)]
	fake.getPaymentArgsForCall = append(fake.getPaymentArgsForCall, struct {
		arg1 context.Context
		arg2 *billing.GetPaymentRequest
		arg3 []client.CallOption
	}{arg1, arg2, arg3})
	stub := fake.GetPaymentStub
	fakeReturns := fake.getPaymentReturns
	fake.recordInvocation("GetPayment", []interface{}{arg1, arg2, arg3})
	fake.getPaymentMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeBillingService) GetPaymentCallCount() int {
	fake.getPaymentMutex.RLock()
	defer fake.getPaymentMutex.RUnlock()
	return len(fake.getPaymentArgsForCall)
}

func (fake *FakeBillingService) GetPaymentCalls(stub func(context.Context, *billing.GetPaymentRequest, ...client.CallOption) (*billing.GetPaymentResponse, error)) {
	fake.getPaymentMutex.Lock()
	defer fake.getPaymentMutex.Unlock()
	fake.GetPaymentStub = stub
}

func (fake *FakeBillingService) GetPaymentArgsForCall(i int) (context.Context, *billing.GetPaymentRequest, []client.CallOption) {
	fake.getPaymentMutex.RLock()
	defer fake.getPaymentMutex.RUnlock()
	argsForCall := fake.getPaymentArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeBillingService) GetPaymentReturns(result1 *billing.GetPaymentResponse, result2 error) {
	fake.getPaymentMutex.Lock()
	defer fake.getPaymentMutex.Unlock()
	fake.GetPaymentStub = nil
	fake.getPaymentReturns = struct {
		result1 *billing.GetPaymentResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeBillingService) GetPaymentReturnsOnCall(i int, result1 *billing.GetPaymentResponse, result2 error) {
	fake.getPaymentMutex.Lock()
	defer fake.getPaymentMutex.Unlock()
	fake.GetPaymentStub = nil
	if fake.getPaymentReturnsOnCall == nil {
		fake.getPaymentReturnsOnCall = make(map[int]struct {
			result1 *billing.GetPaymentResponse
			result2 error
		})
	}
	fake.getPaymentReturnsOnCall[i] = struct {
		result1 *billing.GetPaymentResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeBillingService) ListCards(arg1 context.Context, arg2 *billing.ListCardsRequest, arg3 ...client.CallOption) (*billing.ListCardsResponse, error) {
	fake.listCardsMutex.Lock()
	ret, specificReturn := fake.listCardsReturnsOnCall[len(fake.listCardsArgsForCall)]
	fake.listCardsArgsForCall = append(fake.listCardsArgsForCall, struct {
		arg1 context.Context
		arg2 *billing.ListCardsRequest
		arg3 []client.CallOption
	}{arg1, arg2, arg3})
	stub := fake.ListCardsStub
	fakeReturns := fake.listCardsReturns
	fake.recordInvocation("ListCards", []interface{}{arg1, arg2, arg3})
	fake.listCardsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeBillingService) ListCardsCallCount() int {
	fake.listCardsMutex.RLock()
	defer fake.listCardsMutex.RUnlock()
	return len(fake.listCardsArgsForCall)
}

func (fake *FakeBillingService) ListCardsCalls(stub func(context.Context, *billing.ListCardsRequest, ...client.CallOption) (*billing.ListCardsResponse, error)) {
	fake.listCardsMutex.Lock()
	defer fake.listCardsMutex.Unlock()
	fake.ListCardsStub = stub
}

func (fake *FakeBillingService) ListCardsArgsForCall(i int) (context.Context, *billing.ListCardsRequest, []client.CallOption) {
	fake.listCardsMutex.RLock()
	defer fake.listCardsMutex.RUnlock()
	argsForCall := fake.listCardsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeBillingService) ListCardsReturns(result1 *billing.ListCardsResponse, result2 error) {
	fake.listCardsMutex.Lock()
	defer fake.listCardsMutex.Unlock()
	fake.ListCardsStub = nil
	fake.listCardsReturns = struct {
		result1 *billing.ListCardsResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeBillingService) ListCardsReturnsOnCall(i int, result1 *billing.ListCardsResponse, result2 error) {
	fake.listCardsMutex.Lock()
	defer fake.listCardsMutex.Unlock()
	fake.ListCardsStub = nil
	if fake.listCardsReturnsOnCall == nil {
		fake.listCardsReturnsOnCall = make(map[int]struct {
			result1 *billing.ListCardsResponse
			result2 error
		})
	}
	fake.listCardsReturnsOnCall[i] = struct {
		result1 *billing.ListCardsResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeBillingService) ListPayments(arg1 context.Context, arg2 *billing.ListPaymentsRequest, arg3 ...client.CallOption) (*billing.ListPaymentsResponse, error) {
	fake.listPaymentsMutex.Lock()
	ret, specificReturn := fake.listPaymentsReturnsOnCall[len(fake.listPaymentsArgsForCall)]
	fake.listPaymentsArgsForCall = append(fake.listPaymentsArgsForCall, struct {
		arg1 context.Context
		arg2 *billing.ListPaymentsRequest
		arg3 []client.CallOption
	}{arg1, arg2, arg3})
	stub := fake.ListPaymentsStub
	fakeReturns := fake.listPaymentsReturns
	fake.recordInvocation("ListPayments", []interface{}{arg1, arg2, arg3})
	fake.listPaymentsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeBillingService) ListPaymentsCallCount() int {
	fake.listPaymentsMutex.RLock()
	defer fake.listPaymentsMutex.RUnlock()
	return len(fake.listPaymentsArgsForCall)
}

func (fake *FakeBillingService) ListPaymentsCalls(stub func(context.Context, *billing.ListPaymentsRequest, ...client.CallOption) (*billing.ListPaymentsResponse, error)) {
	fake.listPaymentsMutex.Lock()
	defer fake.listPaymentsMutex.Unlock()
	fake.ListPaymentsStub = stub
}

func (fake *FakeBillingService) ListPaymentsArgsForCall(i int) (context.Context, *billing.ListPaymentsRequest, []client.CallOption) {
	fake.listPaymentsMutex.RLock()
	defer fake.listPaymentsMutex.RUnlock()
	argsForCall := fake.listPaymentsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeBillingService) ListPaymentsReturns(result1 *billing.ListPaymentsResponse, result2 error) {
	fake.listPaymentsMutex.Lock()
	defer fake.listPaymentsMutex.Unlock()
	fake.ListPaymentsStub = nil
	fake.listPaymentsReturns = struct {
		result1 *billing.ListPaymentsResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeBillingService) ListPaymentsReturnsOnCall(i int, result1 *billing.ListPaymentsResponse, result2 error) {
	fake.listPaymentsMutex.Lock()
	defer fake.listPaymentsMutex.Unlock()
	fake.ListPaymentsStub = nil
	if fake.listPaymentsReturnsOnCall == nil {
		fake.listPaymentsReturnsOnCall = make(map[int]struct {
			result1 *billing.ListPaymentsResponse
			result2 error
		})
	}
	fake.listPaymentsReturnsOnCall[i] = struct {
		result1 *billing.ListPaymentsResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeBillingService) ReadAccount(arg1 context.Context, arg2 *billing.ReadAccountRequest, arg3 ...client.CallOption) (*billing.ReadAccountResponse, error) {
	fake.readAccountMutex.Lock()
	ret, specificReturn := fake.readAccountReturnsOnCall[len(fake.readAccountArgsForCall)]
	fake.readAccountArgsForCall = append(fake.readAccountArgsForCall, struct {
		arg1 context.Context
		arg2 *billing.ReadAccountRequest
		arg3 []client.CallOption
	}{arg1, arg2, arg3})
	stub := fake.ReadAccountStub
	fakeReturns := fake.readAccountReturns
	fake.recordInvocation("ReadAccount", []interface{}{arg1, arg2, arg3})
	fake.readAccountMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeBillingService) ReadAccountCallCount() int {
	fake.readAccountMutex.RLock()
	defer fake.readAccountMutex.RUnlock()
	return len(fake.readAccountArgsForCall)
}

func (fake *FakeBillingService) ReadAccountCalls(stub func(context.Context, *billing.ReadAccountRequest, ...client.CallOption) (*billing.ReadAccountResponse, error)) {
	fake.readAccountMutex.Lock()
	defer fake.readAccountMutex.Unlock()
	fake.ReadAccountStub = stub
}

func (fake *FakeBillingService) ReadAccountArgsForCall(i int) (context.Context, *billing.ReadAccountRequest, []client.CallOption) {
	fake.readAccountMutex.RLock()
	defer fake.readAccountMutex.RUnlock()
	argsForCall := fake.readAccountArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeBillingService) ReadAccountReturns(result1 *billing.ReadAccountResponse, result2 error) {
	fake.readAccountMutex.Lock()
	defer fake.readAccountMutex.Unlock()
	fake.ReadAccountStub = nil
	fake.readAccountReturns = struct {
		result1 *billing.ReadAccountResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeBillingService) ReadAccountReturnsOnCall(i int, result1 *billing.ReadAccountResponse, result2 error) {
	fake.readAccountMutex.Lock()
	defer fake.readAccountMutex.Unlock()
	fake.ReadAccountStub = nil
	if fake.readAccountReturnsOnCall == nil {
		fake.readAccountReturnsOnCall = make(map[int]struct {
			result1 *billing.ReadAccountResponse
			result2 error
		})
	}
	fake.readAccountReturnsOnCall[i] = struct {
		result1 *billing.ReadAccountResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeBillingService) SetupCard(arg1 context.Context, arg2 *billing.SetupCardRequest, arg3 ...client.CallOption) (*billing.SetupCardResponse, error) {
	fake.setupCardMutex.Lock()
	ret, specificReturn := fake.setupCardReturnsOnCall[len(fake.setupCardArgsForCall)]
	fake.setupCardArgsForCall = append(fake.setupCardArgsForCall, struct {
		arg1 context.Context
		arg2 *billing.SetupCardRequest
		arg3 []client.CallOption
	}{arg1, arg2, arg3})
	stub := fake.SetupCardStub
	fakeReturns := fake.setupCardReturns
	fake.recordInvocation("SetupCard", []interface{}{arg1, arg2, arg3})
	fake.setupCardMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeBillingService) SetupCardCallCount() int {
	fake.setupCardMutex.RLock()
	defer fake.setupCardMutex.RUnlock()
	return len(fake.setupCardArgsForCall)
}

func (fake *FakeBillingService) SetupCardCalls(stub func(context.Context, *billing.SetupCardRequest, ...client.CallOption) (*billing.SetupCardResponse, error)) {
	fake.setupCardMutex.Lock()
	defer fake.setupCardMutex.Unlock()
	fake.SetupCardStub = stub
}

func (fake *FakeBillingService) SetupCardArgsForCall(i int) (context.Context, *billing.SetupCardRequest, []client.CallOption) {
	fake.setupCardMutex.RLock()
	defer fake.setupCardMutex.RUnlock()
	argsForCall := fake.setupCardArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeBillingService) SetupCardReturns(result1 *billing.SetupCardResponse, result2 error) {
	fake.setupCardMutex.Lock()
	defer fake.setupCardMutex.Unlock()
	fake.SetupCardStub = nil
	fake.setupCardReturns = struct {
		result1 *billing.SetupCardResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeBillingService) SetupCardReturnsOnCall(i int, result1 *billing.SetupCardResponse, result2 error) {
	fake.setupCardMutex.Lock()
	defer fake.setupCardMutex.Unlock()
	fake.SetupCardStub = nil
	if fake.setupCardReturnsOnCall == nil {
		fake.setupCardReturnsOnCall = make(map[int]struct {
			result1 *billing.SetupCardResponse
			result2 error
		})
	}
	fake.setupCardReturnsOnCall[i] = struct {
		result1 *billing.SetupCardResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeBillingService) SubscribeTier(arg1 context.Context, arg2 *billing.SubscribeTierRequest, arg3 ...client.CallOption) (*billing.SubscribeTierResponse, error) {
	fake.subscribeTierMutex.Lock()
	ret, specificReturn := fake.subscribeTierReturnsOnCall[len(fake.subscribeTierArgsForCall)]
	fake.subscribeTierArgsForCall = append(fake.subscribeTierArgsForCall, struct {
		arg1 context.Context
		arg2 *billing.SubscribeTierRequest
		arg3 []client.CallOption
	}{arg1, arg2, arg3})
	stub := fake.SubscribeTierStub
	fakeReturns := fake.subscribeTierReturns
	fake.recordInvocation("SubscribeTier", []interface{}{arg1, arg2, arg3})
	fake.subscribeTierMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeBillingService) SubscribeTierCallCount() int {
	fake.subscribeTierMutex.RLock()
	defer fake.subscribeTierMutex.RUnlock()
	return len(fake.subscribeTierArgsForCall)
}

func (fake *FakeBillingService) SubscribeTierCalls(stub func(context.Context, *billing.SubscribeTierRequest, ...client.CallOption) (*billing.SubscribeTierResponse, error)) {
	fake.subscribeTierMutex.Lock()
	defer fake.subscribeTierMutex.Unlock()
	fake.SubscribeTierStub = stub
}

func (fake *FakeBillingService) SubscribeTierArgsForCall(i int) (context.Context, *billing.SubscribeTierRequest, []client.CallOption) {
	fake.subscribeTierMutex.RLock()
	defer fake.subscribeTierMutex.RUnlock()
	argsForCall := fake.subscribeTierArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeBillingService) SubscribeTierReturns(result1 *billing.SubscribeTierResponse, result2 error) {
	fake.subscribeTierMutex.Lock()
	defer fake.subscribeTierMutex.Unlock()
	fake.SubscribeTierStub = nil
	fake.subscribeTierReturns = struct {
		result1 *billing.SubscribeTierResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeBillingService) SubscribeTierReturnsOnCall(i int, result1 *billing.SubscribeTierResponse, result2 error) {
	fake.subscribeTierMutex.Lock()
	defer fake.subscribeTierMutex.Unlock()
	fake.SubscribeTierStub = nil
	if fake.subscribeTierReturnsOnCall == nil {
		fake.subscribeTierReturnsOnCall = make(map[int]struct {
			result1 *billing.SubscribeTierResponse
			result2 error
		})
	}
	fake.subscribeTierReturnsOnCall[i] = struct {
		result1 *billing.SubscribeTierResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeBillingService) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.chargeCardMutex.RLock()
	defer fake.chargeCardMutex.RUnlock()
	fake.createCheckoutSessionMutex.RLock()
	defer fake.createCheckoutSessionMutex.RUnlock()
	fake.deleteCardMutex.RLock()
	defer fake.deleteCardMutex.RUnlock()
	fake.getPaymentMutex.RLock()
	defer fake.getPaymentMutex.RUnlock()
	fake.listCardsMutex.RLock()
	defer fake.listCardsMutex.RUnlock()
	fake.listPaymentsMutex.RLock()
	defer fake.listPaymentsMutex.RUnlock()
	fake.readAccountMutex.RLock()
	defer fake.readAccountMutex.RUnlock()
	fake.setupCardMutex.RLock()
	defer fake.setupCardMutex.RUnlock()
	fake.subscribeTierMutex.RLock()
	defer fake.subscribeTierMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeBillingService) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ billing.BillingService = new(FakeBillingService)
