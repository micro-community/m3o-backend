// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"context"
	"sync"

	balance "github.com/m3o/services/balance/proto"
	"github.com/micro/micro/v3/service/client"
)

type FakeBalanceService struct {
	CurrentStub        func(context.Context, *balance.CurrentRequest, ...client.CallOption) (*balance.CurrentResponse, error)
	currentMutex       sync.RWMutex
	currentArgsForCall []struct {
		arg1 context.Context
		arg2 *balance.CurrentRequest
		arg3 []client.CallOption
	}
	currentReturns struct {
		result1 *balance.CurrentResponse
		result2 error
	}
	currentReturnsOnCall map[int]struct {
		result1 *balance.CurrentResponse
		result2 error
	}
	DecrementStub        func(context.Context, *balance.DecrementRequest, ...client.CallOption) (*balance.DecrementResponse, error)
	decrementMutex       sync.RWMutex
	decrementArgsForCall []struct {
		arg1 context.Context
		arg2 *balance.DecrementRequest
		arg3 []client.CallOption
	}
	decrementReturns struct {
		result1 *balance.DecrementResponse
		result2 error
	}
	decrementReturnsOnCall map[int]struct {
		result1 *balance.DecrementResponse
		result2 error
	}
	DeleteCustomerStub        func(context.Context, *balance.DeleteCustomerRequest, ...client.CallOption) (*balance.DeleteCustomerResponse, error)
	deleteCustomerMutex       sync.RWMutex
	deleteCustomerArgsForCall []struct {
		arg1 context.Context
		arg2 *balance.DeleteCustomerRequest
		arg3 []client.CallOption
	}
	deleteCustomerReturns struct {
		result1 *balance.DeleteCustomerResponse
		result2 error
	}
	deleteCustomerReturnsOnCall map[int]struct {
		result1 *balance.DeleteCustomerResponse
		result2 error
	}
	IncrementStub        func(context.Context, *balance.IncrementRequest, ...client.CallOption) (*balance.IncrementResponse, error)
	incrementMutex       sync.RWMutex
	incrementArgsForCall []struct {
		arg1 context.Context
		arg2 *balance.IncrementRequest
		arg3 []client.CallOption
	}
	incrementReturns struct {
		result1 *balance.IncrementResponse
		result2 error
	}
	incrementReturnsOnCall map[int]struct {
		result1 *balance.IncrementResponse
		result2 error
	}
	ListAdjustmentsStub        func(context.Context, *balance.ListAdjustmentsRequest, ...client.CallOption) (*balance.ListAdjustmentsResponse, error)
	listAdjustmentsMutex       sync.RWMutex
	listAdjustmentsArgsForCall []struct {
		arg1 context.Context
		arg2 *balance.ListAdjustmentsRequest
		arg3 []client.CallOption
	}
	listAdjustmentsReturns struct {
		result1 *balance.ListAdjustmentsResponse
		result2 error
	}
	listAdjustmentsReturnsOnCall map[int]struct {
		result1 *balance.ListAdjustmentsResponse
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeBalanceService) Current(arg1 context.Context, arg2 *balance.CurrentRequest, arg3 ...client.CallOption) (*balance.CurrentResponse, error) {
	fake.currentMutex.Lock()
	ret, specificReturn := fake.currentReturnsOnCall[len(fake.currentArgsForCall)]
	fake.currentArgsForCall = append(fake.currentArgsForCall, struct {
		arg1 context.Context
		arg2 *balance.CurrentRequest
		arg3 []client.CallOption
	}{arg1, arg2, arg3})
	stub := fake.CurrentStub
	fakeReturns := fake.currentReturns
	fake.recordInvocation("Current", []interface{}{arg1, arg2, arg3})
	fake.currentMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeBalanceService) CurrentCallCount() int {
	fake.currentMutex.RLock()
	defer fake.currentMutex.RUnlock()
	return len(fake.currentArgsForCall)
}

func (fake *FakeBalanceService) CurrentCalls(stub func(context.Context, *balance.CurrentRequest, ...client.CallOption) (*balance.CurrentResponse, error)) {
	fake.currentMutex.Lock()
	defer fake.currentMutex.Unlock()
	fake.CurrentStub = stub
}

func (fake *FakeBalanceService) CurrentArgsForCall(i int) (context.Context, *balance.CurrentRequest, []client.CallOption) {
	fake.currentMutex.RLock()
	defer fake.currentMutex.RUnlock()
	argsForCall := fake.currentArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeBalanceService) CurrentReturns(result1 *balance.CurrentResponse, result2 error) {
	fake.currentMutex.Lock()
	defer fake.currentMutex.Unlock()
	fake.CurrentStub = nil
	fake.currentReturns = struct {
		result1 *balance.CurrentResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeBalanceService) CurrentReturnsOnCall(i int, result1 *balance.CurrentResponse, result2 error) {
	fake.currentMutex.Lock()
	defer fake.currentMutex.Unlock()
	fake.CurrentStub = nil
	if fake.currentReturnsOnCall == nil {
		fake.currentReturnsOnCall = make(map[int]struct {
			result1 *balance.CurrentResponse
			result2 error
		})
	}
	fake.currentReturnsOnCall[i] = struct {
		result1 *balance.CurrentResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeBalanceService) Decrement(arg1 context.Context, arg2 *balance.DecrementRequest, arg3 ...client.CallOption) (*balance.DecrementResponse, error) {
	fake.decrementMutex.Lock()
	ret, specificReturn := fake.decrementReturnsOnCall[len(fake.decrementArgsForCall)]
	fake.decrementArgsForCall = append(fake.decrementArgsForCall, struct {
		arg1 context.Context
		arg2 *balance.DecrementRequest
		arg3 []client.CallOption
	}{arg1, arg2, arg3})
	stub := fake.DecrementStub
	fakeReturns := fake.decrementReturns
	fake.recordInvocation("Decrement", []interface{}{arg1, arg2, arg3})
	fake.decrementMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeBalanceService) DecrementCallCount() int {
	fake.decrementMutex.RLock()
	defer fake.decrementMutex.RUnlock()
	return len(fake.decrementArgsForCall)
}

func (fake *FakeBalanceService) DecrementCalls(stub func(context.Context, *balance.DecrementRequest, ...client.CallOption) (*balance.DecrementResponse, error)) {
	fake.decrementMutex.Lock()
	defer fake.decrementMutex.Unlock()
	fake.DecrementStub = stub
}

func (fake *FakeBalanceService) DecrementArgsForCall(i int) (context.Context, *balance.DecrementRequest, []client.CallOption) {
	fake.decrementMutex.RLock()
	defer fake.decrementMutex.RUnlock()
	argsForCall := fake.decrementArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeBalanceService) DecrementReturns(result1 *balance.DecrementResponse, result2 error) {
	fake.decrementMutex.Lock()
	defer fake.decrementMutex.Unlock()
	fake.DecrementStub = nil
	fake.decrementReturns = struct {
		result1 *balance.DecrementResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeBalanceService) DecrementReturnsOnCall(i int, result1 *balance.DecrementResponse, result2 error) {
	fake.decrementMutex.Lock()
	defer fake.decrementMutex.Unlock()
	fake.DecrementStub = nil
	if fake.decrementReturnsOnCall == nil {
		fake.decrementReturnsOnCall = make(map[int]struct {
			result1 *balance.DecrementResponse
			result2 error
		})
	}
	fake.decrementReturnsOnCall[i] = struct {
		result1 *balance.DecrementResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeBalanceService) DeleteCustomer(arg1 context.Context, arg2 *balance.DeleteCustomerRequest, arg3 ...client.CallOption) (*balance.DeleteCustomerResponse, error) {
	fake.deleteCustomerMutex.Lock()
	ret, specificReturn := fake.deleteCustomerReturnsOnCall[len(fake.deleteCustomerArgsForCall)]
	fake.deleteCustomerArgsForCall = append(fake.deleteCustomerArgsForCall, struct {
		arg1 context.Context
		arg2 *balance.DeleteCustomerRequest
		arg3 []client.CallOption
	}{arg1, arg2, arg3})
	stub := fake.DeleteCustomerStub
	fakeReturns := fake.deleteCustomerReturns
	fake.recordInvocation("DeleteCustomer", []interface{}{arg1, arg2, arg3})
	fake.deleteCustomerMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeBalanceService) DeleteCustomerCallCount() int {
	fake.deleteCustomerMutex.RLock()
	defer fake.deleteCustomerMutex.RUnlock()
	return len(fake.deleteCustomerArgsForCall)
}

func (fake *FakeBalanceService) DeleteCustomerCalls(stub func(context.Context, *balance.DeleteCustomerRequest, ...client.CallOption) (*balance.DeleteCustomerResponse, error)) {
	fake.deleteCustomerMutex.Lock()
	defer fake.deleteCustomerMutex.Unlock()
	fake.DeleteCustomerStub = stub
}

func (fake *FakeBalanceService) DeleteCustomerArgsForCall(i int) (context.Context, *balance.DeleteCustomerRequest, []client.CallOption) {
	fake.deleteCustomerMutex.RLock()
	defer fake.deleteCustomerMutex.RUnlock()
	argsForCall := fake.deleteCustomerArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeBalanceService) DeleteCustomerReturns(result1 *balance.DeleteCustomerResponse, result2 error) {
	fake.deleteCustomerMutex.Lock()
	defer fake.deleteCustomerMutex.Unlock()
	fake.DeleteCustomerStub = nil
	fake.deleteCustomerReturns = struct {
		result1 *balance.DeleteCustomerResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeBalanceService) DeleteCustomerReturnsOnCall(i int, result1 *balance.DeleteCustomerResponse, result2 error) {
	fake.deleteCustomerMutex.Lock()
	defer fake.deleteCustomerMutex.Unlock()
	fake.DeleteCustomerStub = nil
	if fake.deleteCustomerReturnsOnCall == nil {
		fake.deleteCustomerReturnsOnCall = make(map[int]struct {
			result1 *balance.DeleteCustomerResponse
			result2 error
		})
	}
	fake.deleteCustomerReturnsOnCall[i] = struct {
		result1 *balance.DeleteCustomerResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeBalanceService) Increment(arg1 context.Context, arg2 *balance.IncrementRequest, arg3 ...client.CallOption) (*balance.IncrementResponse, error) {
	fake.incrementMutex.Lock()
	ret, specificReturn := fake.incrementReturnsOnCall[len(fake.incrementArgsForCall)]
	fake.incrementArgsForCall = append(fake.incrementArgsForCall, struct {
		arg1 context.Context
		arg2 *balance.IncrementRequest
		arg3 []client.CallOption
	}{arg1, arg2, arg3})
	stub := fake.IncrementStub
	fakeReturns := fake.incrementReturns
	fake.recordInvocation("Increment", []interface{}{arg1, arg2, arg3})
	fake.incrementMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeBalanceService) IncrementCallCount() int {
	fake.incrementMutex.RLock()
	defer fake.incrementMutex.RUnlock()
	return len(fake.incrementArgsForCall)
}

func (fake *FakeBalanceService) IncrementCalls(stub func(context.Context, *balance.IncrementRequest, ...client.CallOption) (*balance.IncrementResponse, error)) {
	fake.incrementMutex.Lock()
	defer fake.incrementMutex.Unlock()
	fake.IncrementStub = stub
}

func (fake *FakeBalanceService) IncrementArgsForCall(i int) (context.Context, *balance.IncrementRequest, []client.CallOption) {
	fake.incrementMutex.RLock()
	defer fake.incrementMutex.RUnlock()
	argsForCall := fake.incrementArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeBalanceService) IncrementReturns(result1 *balance.IncrementResponse, result2 error) {
	fake.incrementMutex.Lock()
	defer fake.incrementMutex.Unlock()
	fake.IncrementStub = nil
	fake.incrementReturns = struct {
		result1 *balance.IncrementResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeBalanceService) IncrementReturnsOnCall(i int, result1 *balance.IncrementResponse, result2 error) {
	fake.incrementMutex.Lock()
	defer fake.incrementMutex.Unlock()
	fake.IncrementStub = nil
	if fake.incrementReturnsOnCall == nil {
		fake.incrementReturnsOnCall = make(map[int]struct {
			result1 *balance.IncrementResponse
			result2 error
		})
	}
	fake.incrementReturnsOnCall[i] = struct {
		result1 *balance.IncrementResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeBalanceService) ListAdjustments(arg1 context.Context, arg2 *balance.ListAdjustmentsRequest, arg3 ...client.CallOption) (*balance.ListAdjustmentsResponse, error) {
	fake.listAdjustmentsMutex.Lock()
	ret, specificReturn := fake.listAdjustmentsReturnsOnCall[len(fake.listAdjustmentsArgsForCall)]
	fake.listAdjustmentsArgsForCall = append(fake.listAdjustmentsArgsForCall, struct {
		arg1 context.Context
		arg2 *balance.ListAdjustmentsRequest
		arg3 []client.CallOption
	}{arg1, arg2, arg3})
	stub := fake.ListAdjustmentsStub
	fakeReturns := fake.listAdjustmentsReturns
	fake.recordInvocation("ListAdjustments", []interface{}{arg1, arg2, arg3})
	fake.listAdjustmentsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeBalanceService) ListAdjustmentsCallCount() int {
	fake.listAdjustmentsMutex.RLock()
	defer fake.listAdjustmentsMutex.RUnlock()
	return len(fake.listAdjustmentsArgsForCall)
}

func (fake *FakeBalanceService) ListAdjustmentsCalls(stub func(context.Context, *balance.ListAdjustmentsRequest, ...client.CallOption) (*balance.ListAdjustmentsResponse, error)) {
	fake.listAdjustmentsMutex.Lock()
	defer fake.listAdjustmentsMutex.Unlock()
	fake.ListAdjustmentsStub = stub
}

func (fake *FakeBalanceService) ListAdjustmentsArgsForCall(i int) (context.Context, *balance.ListAdjustmentsRequest, []client.CallOption) {
	fake.listAdjustmentsMutex.RLock()
	defer fake.listAdjustmentsMutex.RUnlock()
	argsForCall := fake.listAdjustmentsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeBalanceService) ListAdjustmentsReturns(result1 *balance.ListAdjustmentsResponse, result2 error) {
	fake.listAdjustmentsMutex.Lock()
	defer fake.listAdjustmentsMutex.Unlock()
	fake.ListAdjustmentsStub = nil
	fake.listAdjustmentsReturns = struct {
		result1 *balance.ListAdjustmentsResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeBalanceService) ListAdjustmentsReturnsOnCall(i int, result1 *balance.ListAdjustmentsResponse, result2 error) {
	fake.listAdjustmentsMutex.Lock()
	defer fake.listAdjustmentsMutex.Unlock()
	fake.ListAdjustmentsStub = nil
	if fake.listAdjustmentsReturnsOnCall == nil {
		fake.listAdjustmentsReturnsOnCall = make(map[int]struct {
			result1 *balance.ListAdjustmentsResponse
			result2 error
		})
	}
	fake.listAdjustmentsReturnsOnCall[i] = struct {
		result1 *balance.ListAdjustmentsResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeBalanceService) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.currentMutex.RLock()
	defer fake.currentMutex.RUnlock()
	fake.decrementMutex.RLock()
	defer fake.decrementMutex.RUnlock()
	fake.deleteCustomerMutex.RLock()
	defer fake.deleteCustomerMutex.RUnlock()
	fake.incrementMutex.RLock()
	defer fake.incrementMutex.RUnlock()
	fake.listAdjustmentsMutex.RLock()
	defer fake.listAdjustmentsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeBalanceService) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ balance.BalanceService = new(FakeBalanceService)
